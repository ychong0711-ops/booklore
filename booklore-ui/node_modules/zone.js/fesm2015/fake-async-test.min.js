'use strict';
/**
 * @license Angular
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */
var N=Object.defineProperty;var x=Object.getOwnPropertySymbols;var C=Object.prototype.hasOwnProperty,O=Object.prototype.propertyIsEnumerable;var I=(i,e,t)=>e in i?N(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,F=(i,e)=>{for(var t in e||(e={}))C.call(e,t)&&I(i,t,e[t]);if(x)for(var t of x(e))O.call(e,t)&&I(i,t,e[t]);return i};var l=(i,e,t)=>(I(i,typeof e!="symbol"?e+"":e,t),t);var _=(i,e,t)=>new Promise((s,r)=>{var o=u=>{try{c(t.next(u))}catch(d){r(d)}},n=u=>{try{c(t.throw(u))}catch(d){r(d)}},c=u=>u.done?s(u.value):Promise.resolve(u.value).then(o,n);c((t=t.apply(i,e)).next())});function E(){throw typeof jest!="undefined"&&jest.__zone_patch__?new Error("Only globals are patched with zone-testing. If you import `it`, `describe`, etc. directly, you cannot use `fakeAsync` or `waitForAsync`."):new Error("ProxyZoneSpec is needed for the fakeAsync and waitForAsync test helpers but could not be found. Make sure that your environment includes zone-testing.js")}var a=typeof window=="object"&&window||typeof self=="object"&&self||globalThis.global,b=a.setImmediate,Z=a.setTimeout,m=a.Date;function k(){if(arguments.length===0){let i=new m;return i.setTime(k.now()),i}else{let i=Array.prototype.slice.call(arguments);return new m(...i)}}k.now=function(){let i=Zone.current.get("FakeAsyncTestZoneSpec");return i?i.getFakeSystemTime():m.now.apply(this,arguments)};k.UTC=m.UTC;k.parse=m.parse;var T,H=function(){},p=class p{constructor(){l(this,"_schedulerQueue",[]);l(this,"_currentTickTime",0);l(this,"_currentFakeBaseSystemTime",m.now());l(this,"_currentTickRequeuePeriodicEntries",[])}static getNextId(){let e=T.nativeSetTimeout.call(a,H,0);return T.nativeClearTimeout.call(a,e),typeof e=="number"?e:p.nextNodeJSId++}getCurrentTickTime(){return this._currentTickTime}getFakeSystemTime(){return this._currentFakeBaseSystemTime+this._currentTickTime}setFakeBaseSystemTime(e){this._currentFakeBaseSystemTime=e}getRealSystemTime(){return m.now()}scheduleFunction(e,t,s){s=F({args:[],isPeriodic:!1,isRequestAnimationFrame:!1,id:-1,isRequeuePeriodic:!1},s);let r=s.id<0?p.nextId:s.id;p.nextId=p.getNextId();let n={endTime:this._currentTickTime+t,id:r,func:e,args:s.args,delay:t,isPeriodic:s.isPeriodic,isRequestAnimationFrame:s.isRequestAnimationFrame};s.isRequeuePeriodic&&this._currentTickRequeuePeriodicEntries.push(n);let c=0;for(;c<this._schedulerQueue.length;c++){let u=this._schedulerQueue[c];if(n.endTime<u.endTime)break}return this._schedulerQueue.splice(c,0,n),r}removeScheduledFunctionWithId(e){for(let t=0;t<this._schedulerQueue.length;t++)if(this._schedulerQueue[t].id==e){this._schedulerQueue.splice(t,1);break}}removeAll(){this._schedulerQueue=[]}getTimerCount(){return this._schedulerQueue.length}tickToNext(e=1,t,s){if(this._schedulerQueue.length<e)return;let r=this._currentTickTime,o=this._schedulerQueue[e-1];this.tick(o.endTime-r,t,s)}tick(e=0,t,s){let r=this._currentTickTime+e,o=0;s=Object.assign({processNewMacroTasksSynchronously:!0},s);let n=s.processNewMacroTasksSynchronously?this._schedulerQueue:this._schedulerQueue.slice();if(n.length===0&&t){t(e);return}for(;n.length>0;){this._currentTickRequeuePeriodicEntries=[];let c=n[0];if(r<c.endTime)break;{let u=n.shift();if(!s.processNewMacroTasksSynchronously){let f=this._schedulerQueue.indexOf(u);f>=0&&this._schedulerQueue.splice(f,1)}if(o=this._currentTickTime,this._currentTickTime=u.endTime,t&&t(this._currentTickTime-o),!u.func.apply(a,u.isRequestAnimationFrame?[this._currentTickTime]:u.args))break;s.processNewMacroTasksSynchronously||this._currentTickRequeuePeriodicEntries.forEach(f=>{let w=0;for(;w<n.length;w++){let Q=n[w];if(f.endTime<Q.endTime)break}n.splice(w,0,f)})}}o=this._currentTickTime,this._currentTickTime=r,t&&t(this._currentTickTime-o)}executeNextTask(e){let t=this._schedulerQueue.shift();t!==void 0&&(e==null||e(t.endTime-this._currentTickTime),this._currentTickTime=t.endTime,t.func.apply(a,t.isRequestAnimationFrame?[this._currentTickTime]:t.args))}flushOnlyPendingTimers(e){if(this._schedulerQueue.length===0)return 0;let t=this._currentTickTime,s=this._schedulerQueue[this._schedulerQueue.length-1];return this.tick(s.endTime-t,e,{processNewMacroTasksSynchronously:!1}),this._currentTickTime-t}flush(e=20,t=!1,s){return t?this.flushPeriodic(s):this.flushNonPeriodic(e,s)}flushPeriodic(e){if(this._schedulerQueue.length===0)return 0;let t=this._currentTickTime,s=this._schedulerQueue[this._schedulerQueue.length-1];return this.tick(s.endTime-t,e),this._currentTickTime-t}flushNonPeriodic(e,t){let s=this._currentTickTime,r=0,o=0;for(;this._schedulerQueue.length>0;){if(o++,o>e)throw new Error("flush failed after reaching the limit of "+e+" tasks. Does your code use a polling timeout?");if(this._schedulerQueue.filter(u=>!u.isPeriodic&&!u.isRequestAnimationFrame).length===0)break;let n=this._schedulerQueue.shift();if(r=this._currentTickTime,this._currentTickTime=n.endTime,t&&t(this._currentTickTime-r),!n.func.apply(a,n.args))break}return this._currentTickTime-s}};l(p,"nextNodeJSId",1),l(p,"nextId",-1);var g=p,A=class i{constructor(e,t=!1,s){l(this,"trackPendingRequestAnimationFrame");l(this,"macroTaskOptions");l(this,"_scheduler",new g);l(this,"_microtasks",[]);l(this,"_lastError",null);l(this,"_uncaughtPromiseErrors",Promise[Zone.__symbol__("uncaughtPromiseErrors")]);l(this,"pendingPeriodicTimers",[]);l(this,"pendingTimers",[]);l(this,"patchDateLocked",!1);l(this,"tickMode",{counter:0,mode:"manual"});l(this,"name");l(this,"properties",{FakeAsyncTestZoneSpec:this});this.trackPendingRequestAnimationFrame=t,this.macroTaskOptions=s,this.name="fakeAsyncTestZone for "+e,this.macroTaskOptions||(this.macroTaskOptions=a[Zone.__symbol__("FakeAsyncTestMacroTask")])}static assertInZone(){if(Zone.current.get("FakeAsyncTestZoneSpec")==null)throw new Error("The code should be running in the fakeAsync zone to call this function")}_fnAndFlush(e,t){return(...s)=>(e.apply(a,s),this._lastError===null?(t.onSuccess!=null&&t.onSuccess.apply(a),this.flushMicrotasks()):t.onError!=null&&t.onError.apply(a),this._lastError===null)}static _removeTimer(e,t){let s=e.indexOf(t);s>-1&&e.splice(s,1)}_dequeueTimer(e){return()=>{i._removeTimer(this.pendingTimers,e)}}_requeuePeriodicTimer(e,t,s,r){return()=>{this.pendingPeriodicTimers.indexOf(r)!==-1&&this._scheduler.scheduleFunction(e,t,{args:s,isPeriodic:!0,id:r,isRequeuePeriodic:!0})}}_dequeuePeriodicTimer(e){return()=>{i._removeTimer(this.pendingPeriodicTimers,e)}}_setTimeout(e,t,s,r=!0){let o=this._dequeueTimer(g.nextId),n=this._fnAndFlush(e,{onSuccess:o,onError:o}),c=this._scheduler.scheduleFunction(n,t,{args:s,isRequestAnimationFrame:!r});return r&&this.pendingTimers.push(c),c}_clearTimeout(e){i._removeTimer(this.pendingTimers,e),this._scheduler.removeScheduledFunctionWithId(e)}_setInterval(e,t,s){let r=g.nextId,o={onSuccess:null,onError:this._dequeuePeriodicTimer(r)},n=this._fnAndFlush(e,o);return o.onSuccess=this._requeuePeriodicTimer(n,t,s,r),this._scheduler.scheduleFunction(n,t,{args:s,isPeriodic:!0}),this.pendingPeriodicTimers.push(r),r}_clearInterval(e){i._removeTimer(this.pendingPeriodicTimers,e),this._scheduler.removeScheduledFunctionWithId(e)}_resetLastErrorAndThrow(){let e=this._lastError||this._uncaughtPromiseErrors[0];throw this._uncaughtPromiseErrors.length=0,this._lastError=null,e}getCurrentTickTime(){return this._scheduler.getCurrentTickTime()}getFakeSystemTime(){return this._scheduler.getFakeSystemTime()}setFakeBaseSystemTime(e){this._scheduler.setFakeBaseSystemTime(e)}getRealSystemTime(){return this._scheduler.getRealSystemTime()}static patchDate(){a[Zone.__symbol__("disableDatePatching")]||a.Date!==k&&(a.Date=k,k.prototype=m.prototype,i.checkTimerPatch())}static resetDate(){a.Date===k&&(a.Date=m)}static checkTimerPatch(){if(!T)throw new Error("Expected timers to have been patched.");a.setTimeout!==T.setTimeout&&(a.setTimeout=T.setTimeout,a.clearTimeout=T.clearTimeout),a.setInterval!==T.setInterval&&(a.setInterval=T.setInterval,a.clearInterval=T.clearInterval)}lockDatePatch(){this.patchDateLocked=!0,i.patchDate()}unlockDatePatch(){this.patchDateLocked=!1,i.resetDate()}setTickMode(e,t){e!==this.tickMode.mode&&(this.tickMode.counter++,this.tickMode.mode=e,e==="automatic"&&this.advanceUntilModeChanges(t))}advanceUntilModeChanges(e){i.assertInZone();let t=Zone.current,{counter:s}=this.tickMode;Zone.root.run(()=>_(this,null,function*(){if(yield v(()=>_(this,null,function*(){yield void 0,t.run(()=>{this.flushMicrotasks()})})),this.tickMode.counter===s)for(;;){if(yield v(()=>this.newMacrotask(t)),this.tickMode.counter!==s)return;yield v(()=>t.run(()=>{this._scheduler.executeNextTask(e)}))}}))}newMacrotask(e){return _(this,null,function*(){if(b)yield new Promise(t=>{b(t)});else{let t=new MessageChannel;yield new Promise(s=>{t.port1.onmessage=s,t.port2.postMessage(void 0)}),t.port1.close(),t.port2.close(),yield new Promise(s=>{Z(s)})}e.run(()=>{this.flushMicrotasks()})})}tickToNext(e=1,t,s={processNewMacroTasksSynchronously:!0}){e<=0||(i.assertInZone(),this.flushMicrotasks(),this._scheduler.tickToNext(e,t,s),this._lastError!==null&&this._resetLastErrorAndThrow())}tick(e=0,t,s={processNewMacroTasksSynchronously:!0}){i.assertInZone(),this.flushMicrotasks(),this._scheduler.tick(e,t,s),this._lastError!==null&&this._resetLastErrorAndThrow()}flushMicrotasks(){i.assertInZone();let e=()=>{(this._lastError!==null||this._uncaughtPromiseErrors.length)&&this._resetLastErrorAndThrow()};for(;this._microtasks.length>0;){let t=this._microtasks.shift();t.func.apply(t.target,t.args)}e()}flush(e,t,s){i.assertInZone(),this.flushMicrotasks();let r=this._scheduler.flush(e,t,s);return this._lastError!==null&&this._resetLastErrorAndThrow(),r}flushOnlyPendingTimers(e){i.assertInZone(),this.flushMicrotasks();let t=this._scheduler.flushOnlyPendingTimers(e);return this._lastError!==null&&this._resetLastErrorAndThrow(),t}removeAllTimers(){i.assertInZone(),this._scheduler.removeAll(),this.pendingPeriodicTimers=[],this.pendingTimers=[]}getTimerCount(){return this._scheduler.getTimerCount()+this._microtasks.length}onScheduleTask(e,t,s,r){switch(r.type){case"microTask":let o=r.data&&r.data.args,n;if(o){let c=r.data.cbIdx;typeof o.length=="number"&&o.length>c+1&&(n=Array.prototype.slice.call(o,c+1))}this._microtasks.push({func:r.invoke,args:n,target:r.data&&r.data.target});break;case"macroTask":switch(r.source){case"setTimeout":r.data.handleId=this._setTimeout(r.invoke,r.data.delay,Array.prototype.slice.call(r.data.args,2));break;case"setImmediate":r.data.handleId=this._setTimeout(r.invoke,0,Array.prototype.slice.call(r.data.args,1));break;case"setInterval":r.data.handleId=this._setInterval(r.invoke,r.data.delay,Array.prototype.slice.call(r.data.args,2));break;case"XMLHttpRequest.send":if(this.tickMode.mode==="manual")throw new Error("Cannot make XHRs from within a fake async test. Request URL: "+r.data.url);r=e.scheduleTask(s,r);break;case"requestAnimationFrame":case"webkitRequestAnimationFrame":case"mozRequestAnimationFrame":r.data.handleId=this._setTimeout(r.invoke,16,r.data.args,this.trackPendingRequestAnimationFrame);break;default:let c=this.findMacroTaskOption(r);if(c){let u=r.data&&r.data.args,d=u&&u.length>1?u[1]:0,f=c.callbackArgs?c.callbackArgs:u;c.isPeriodic?(r.data.handleId=this._setInterval(r.invoke,d,f),r.data.isPeriodic=!0):r.data.handleId=this._setTimeout(r.invoke,d,f);break}throw new Error("Unknown macroTask scheduled in fake async test: "+r.source)}break;case"eventTask":r=e.scheduleTask(s,r);break}return r}onCancelTask(e,t,s,r){switch(r.source){case"setTimeout":case"requestAnimationFrame":case"webkitRequestAnimationFrame":case"mozRequestAnimationFrame":return this._clearTimeout(r.data.handleId);case"setInterval":return this._clearInterval(r.data.handleId);default:let o=this.findMacroTaskOption(r);if(o){let n=r.data.handleId;return o.isPeriodic?this._clearInterval(n):this._clearTimeout(n)}return e.cancelTask(s,r)}}onInvoke(e,t,s,r,o,n,c){try{return i.patchDate(),e.invoke(s,r,o,n,c)}finally{this.patchDateLocked||i.resetDate()}}findMacroTaskOption(e){if(!this.macroTaskOptions)return null;for(let t=0;t<this.macroTaskOptions.length;t++){let s=this.macroTaskOptions[t];if(s.source===e.source)return s}return null}onHandleError(e,t,s,r){return this._lastError=r,!1}},h=null;function S(){return Zone&&Zone.ProxyZoneSpec}var y=null,M=null;function q(){var i,e;h&&h.unlockDatePatch(),h=null,(e=(i=S())==null?void 0:i.get())==null||e.resetDelegate(),y==null||y.resetDelegate()}function j(i,e={}){let{flush:t=!0}=e,s=function(...r){let o=S();o||E();let n=o.assertPresent();if(Zone.current.get("FakeAsyncTestZoneSpec"))throw new Error("fakeAsync() calls can not be nested");try{if(!h){let d=Zone&&Zone.FakeAsyncTestZoneSpec;if(n.getDelegate()instanceof d)throw new Error("fakeAsync() calls can not be nested");h=new d}let c,u=n.getDelegate();n.setDelegate(h),h.lockDatePatch();try{c=i.apply(this,r),t?h.flush(20,!0):R()}finally{n.setDelegate(u)}if(!t){if(h.pendingPeriodicTimers.length>0)throw new Error(`${h.pendingPeriodicTimers.length} periodic timer(s) still in the queue.`);if(h.pendingTimers.length>0)throw new Error(`${h.pendingTimers.length} timer(s) still in the queue.`)}return c}finally{q()}};return s.isFakeAsync=!0,s}function P(){if(h==null&&(h=Zone.current.get("FakeAsyncTestZoneSpec"),h==null))throw new Error("The code should be running in the fakeAsync zone to call this function");return h}function L(i=0,e=!1){P().tick(i,null,e)}function z(i){return P().flush(i)}function B(){let i=P(),e=i.pendingPeriodicTimers;i.pendingPeriodicTimers.length=0}function K(i){return function(...t){let s=S();if(s===void 0)throw new Error("ProxyZoneSpec is needed for the withProxyZone() test helper but could not be found. Make sure that your environment includes zone-testing.js");return(s.get()!==void 0?Zone.current:U()).run(i,this,t)}}function U(){let i=S();if(i===void 0)throw new Error("ProxyZoneSpec is needed for withProxyZone but could not be found. Make sure that your environment includes zone-testing.js");return y===null&&(y=new i),M=Zone.root.fork(y),M}function R(){P().flushMicrotasks()}function D(i){i.FakeAsyncTestZoneSpec=A,i.__load_patch("fakeasync",(e,t,s)=>{t[s.symbol("fakeAsyncTest")]={resetFakeAsyncZone:q,flushMicrotasks:R,discardPeriodicTasks:B,tick:L,flush:z,fakeAsync:j,withProxyZone:K}},!0),T={setTimeout:a.setTimeout,setInterval:a.setInterval,clearTimeout:a.clearTimeout,clearInterval:a.clearInterval,nativeSetTimeout:a[i.__symbol__("setTimeout")],nativeClearTimeout:a[i.__symbol__("clearTimeout")]},g.nextId=g.getNextId()}function v(i){return _(this,null,function*(){try{return yield i()}catch(e){$(e)}})}function $(i){Zone.root.run(()=>{Z(()=>{throw i})})}D(Zone);
