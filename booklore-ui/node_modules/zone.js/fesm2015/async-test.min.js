'use strict';
/**
 * @license Angular
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */
var C=Object.defineProperty;var w=(i,e,s)=>e in i?C(i,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):i[e]=s;var r=(i,e,s)=>(w(i,typeof e!="symbol"?e+"":e,s),s);var p=globalThis;function T(i){return(p.__Zone_symbol_prefix||"__zone_symbol__")+i}var P=globalThis,d=class i{constructor(e,s,t){r(this,"finishCallback");r(this,"failCallback");r(this,"_pendingMicroTasks",!1);r(this,"_pendingMacroTasks",!1);r(this,"_alreadyErrored",!1);r(this,"_isSync",!1);r(this,"_existingFinishTimer",null);r(this,"entryFunction",null);r(this,"runZone",Zone.current);r(this,"unresolvedChainedPromiseCount",0);r(this,"supportWaitUnresolvedChainedPromise",!1);r(this,"name");r(this,"properties");this.finishCallback=e,this.failCallback=s,this.name="asyncTestZone for "+t,this.properties={AsyncTestZoneSpec:this},this.supportWaitUnresolvedChainedPromise=P[T("supportWaitUnResolvedChainedPromise")]===!0}static get symbolParentUnresolved(){return T("parentUnresolved")}isUnresolvedChainedPromisePending(){return this.unresolvedChainedPromiseCount>0}_finishCallbackIfDone(){this._existingFinishTimer!==null&&(clearTimeout(this._existingFinishTimer),this._existingFinishTimer=null),this._pendingMicroTasks||this._pendingMacroTasks||this.supportWaitUnresolvedChainedPromise&&this.isUnresolvedChainedPromisePending()||this.runZone.run(()=>{this._existingFinishTimer=setTimeout(()=>{!this._alreadyErrored&&!(this._pendingMicroTasks||this._pendingMacroTasks)&&this.finishCallback()},0)})}patchPromiseForTest(){if(!this.supportWaitUnresolvedChainedPromise)return;let e=Promise[Zone.__symbol__("patchPromiseForTest")];e&&e()}unPatchPromiseForTest(){if(!this.supportWaitUnresolvedChainedPromise)return;let e=Promise[Zone.__symbol__("unPatchPromiseForTest")];e&&e()}onScheduleTask(e,s,t,n){return n.type!=="eventTask"&&(this._isSync=!1),n.type==="microTask"&&n.data&&n.data instanceof Promise&&n.data[i.symbolParentUnresolved]===!0&&this.unresolvedChainedPromiseCount--,e.scheduleTask(t,n)}onInvokeTask(e,s,t,n,l,h){return n.type!=="eventTask"&&(this._isSync=!1),e.invokeTask(t,n,l,h)}onCancelTask(e,s,t,n){return n.type!=="eventTask"&&(this._isSync=!1),e.cancelTask(t,n)}onInvoke(e,s,t,n,l,h,o){this.entryFunction||(this.entryFunction=n);try{return this._isSync=!0,e.invoke(t,n,l,h,o)}finally{this._isSync&&this.entryFunction===n&&this._finishCallbackIfDone()}}onHandleError(e,s,t,n){return e.handleError(t,n)&&(this.failCallback(n),this._alreadyErrored=!0),!1}onHasTask(e,s,t,n){e.hasTask(t,n),s===t&&(n.change=="microTask"?(this._pendingMicroTasks=n.microTask,this._finishCallbackIfDone()):n.change=="macroTask"&&(this._pendingMacroTasks=n.macroTask,this._finishCallbackIfDone()))}};function g(i){i.AsyncTestZoneSpec=d,i.__load_patch("asynctest",(e,s,t)=>{s[t.symbol("asyncTest")]=function(h){return e.jasmine?function(o){o||(o=function(){},o.fail=function(a){throw a}),n(h,this,void 0,o,a=>{if(typeof a=="string")return o.fail(new Error(a));o.fail(a)})}:function(...o){return new Promise((a,_)=>{n(h,this,o,a,_)})}};function n(l,h,o,a,_){let f=s.current,Z=s.AsyncTestZoneSpec;if(Z===void 0)throw new Error("AsyncTestZoneSpec is needed for the async() test helper but could not be found. Please make sure that your environment includes zone.js/plugins/async-test");let k=s.ProxyZoneSpec;if(!k)throw new Error("ProxyZoneSpec is needed for the async() test helper but could not be found. Please make sure that your environment includes zone.js/plugins/proxy");let c=k.get();k.assertPresent();let y=s.current.getZoneWith("ProxyZoneSpec"),m=c.getDelegate();return y.parent.run(()=>{let u=new Z(()=>{c.getDelegate()==u&&c.setDelegate(m),u.unPatchPromiseForTest(),f.run(()=>{a()})},v=>{c.getDelegate()==u&&c.setDelegate(m),u.unPatchPromiseForTest(),f.run(()=>{_(v)})},"test");c.setDelegate(u),u.patchPromiseForTest()}),s.current.runGuarded(l,h,o)}})}g(Zone);
