export * from 'primeng/types/megamenu';
import * as i2 from '@angular/common';
import { CommonModule, isPlatformBrowser } from '@angular/common';
import * as i0 from '@angular/core';
import { Injectable, InjectionToken, inject, EventEmitter, forwardRef, booleanAttribute, numberAttribute, Output, Input, ViewEncapsulation, Component, signal, effect, ViewChild, ContentChildren, ContentChild, ChangeDetectionStrategy, NgModule } from '@angular/core';
import * as i3 from '@angular/router';
import { RouterModule } from '@angular/router';
import { resolve, isNotEmpty, uuid, isEmpty, focus, findSingle, isPrintableCharacter, findLastIndex, isTouchDevice } from '@primeuix/utils';
import { SharedModule, PrimeTemplate } from 'primeng/api';
import * as i5 from 'primeng/badge';
import { BadgeModule } from 'primeng/badge';
import { BaseComponent, PARENT_INSTANCE } from 'primeng/basecomponent';
import * as i1 from 'primeng/bind';
import { Bind } from 'primeng/bind';
import { AngleDownIcon, AngleRightIcon, BarsIcon } from 'primeng/icons';
import { Ripple } from 'primeng/ripple';
import * as i4 from 'primeng/tooltip';
import { TooltipModule } from 'primeng/tooltip';
import { ZIndexUtils } from 'primeng/utils';
import { style } from '@primeuix/styles/megamenu';
import { BaseStyle } from 'primeng/base';

const inlineStyles = {
    rootList: ({ instance }) => ({ 'max-height': instance.scrollHeight, overflow: 'auto' })
};
const classes = {
    root: ({ instance }) => [
        'p-megamenu p-component',
        {
            'p-megamenu-mobile': instance.queryMatches(),
            'p-megamenu-mobile-active': instance.mobileActive,
            'p-megamenu-horizontal': instance.orientation === 'horizontal',
            'p-megamenu-vertical': instance.orientation === 'vertical'
        }
    ],
    start: 'p-megamenu-start',
    button: 'p-megamenu-button',
    rootList: 'p-megamenu-root-list',
    submenuLabel: ({ instance, processedItem }) => [
        'p-megamenu-submenu-label',
        {
            'p-disabled': instance.isItemDisabled(processedItem)
        }
    ],
    item: ({ instance, processedItem }) => [
        'p-megamenu-item',
        instance.getItemProp(processedItem, 'styleClass'),
        instance.getItemProp(processedItem, 'class'),
        {
            'p-megamenu-item-active': instance.isItemActive(processedItem),
            'p-focus': instance.isItemFocused(processedItem),
            'p-disabled': instance.isItemDisabled(processedItem)
        }
    ],
    itemContent: 'p-megamenu-item-content',
    itemLink: 'p-megamenu-item-link',
    itemIcon: 'p-megamenu-item-icon',
    itemLabel: 'p-megamenu-item-label',
    submenuIcon: 'p-megamenu-submenu-icon',
    overlay: 'p-megamenu-overlay',
    grid: 'p-megamenu-grid',
    column: ({ instance, processedItem }) => {
        let length = instance.isItemGroup(processedItem) ? processedItem.items.length : 0;
        let columnClass;
        if (instance.megaMenu.queryMatches())
            columnClass = 'p-megamenu-col-12';
        else {
            switch (length) {
                case 2:
                    columnClass = 'p-megamenu-col-6';
                    break;
                case 3:
                    columnClass = 'p-megamenu-col-4';
                    break;
                case 4:
                    columnClass = 'p-megamenu-col-3';
                    break;
                case 6:
                    columnClass = 'p-megamenu-col-2';
                    break;
                default:
                    columnClass = 'p-megamenu-col-12';
                    break;
            }
        }
        return columnClass;
    },
    submenu: 'p-megamenu-submenu',
    separator: 'p-megamenu-separator',
    end: 'p-megamenu-end'
};
class MegaMenuStyle extends BaseStyle {
    name = 'megamenu';
    style = style;
    classes = classes;
    inlineStyles = inlineStyles;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.5", ngImport: i0, type: MegaMenuStyle, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "21.0.5", ngImport: i0, type: MegaMenuStyle });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.5", ngImport: i0, type: MegaMenuStyle, decorators: [{
            type: Injectable
        }] });
/**
 *
 * MegaMenu is navigation component that displays submenus together.
 *
 * [Live Demo](https://www.primeng.org/megamenu/)
 *
 * @module megamenustyle
 *
 */
var MegaMenuClasses;
(function (MegaMenuClasses) {
    /**
     * Class name of the root element
     */
    MegaMenuClasses["root"] = "p-megamenu";
    /**
     * Class name of the start element
     */
    MegaMenuClasses["start"] = "p-megamenu-start";
    /**
     * Class name of the button element
     */
    MegaMenuClasses["button"] = "p-megamenu-button";
    /**
     * Class name of the root list element
     */
    MegaMenuClasses["rootList"] = "p-megamenu-root-list";
    /**
     * Class name of the submenu item element
     */
    MegaMenuClasses["submenuItem"] = "p-megamenu-submenu-item";
    /**
     * Class name of the item element
     */
    MegaMenuClasses["item"] = "p-megamenu-item";
    /**
     * Class name of the item content element
     */
    MegaMenuClasses["itemContent"] = "p-megamenu-item-content";
    /**
     * Class name of the item link element
     */
    MegaMenuClasses["itemLink"] = "p-megamenu-item-link";
    /**
     * Class name of the item icon element
     */
    MegaMenuClasses["itemIcon"] = "p-megamenu-item-icon";
    /**
     * Class name of the item label element
     */
    MegaMenuClasses["itemLabel"] = "p-megamenu-item-label";
    /**
     * Class name of the submenu icon element
     */
    MegaMenuClasses["submenuIcon"] = "p-megamenu-submenu-icon";
    /**
     * Class name of the panel element
     */
    MegaMenuClasses["panel"] = "p-megamenu-panel";
    /**
     * Class name of the grid element
     */
    MegaMenuClasses["grid"] = "p-megamenu-grid";
    /**
     * Class name of the submenu element
     */
    MegaMenuClasses["submenu"] = "p-megamenu-submenu";
    /**
     * Class name of the submenu item label element
     */
    MegaMenuClasses["submenuItemLabel"] = "p-megamenu-submenu-item-label";
    /**
     * Class name of the separator element
     */
    MegaMenuClasses["separator"] = "p-megamenu-separator";
    /**
     * Class name of the end element
     */
    MegaMenuClasses["end"] = "p-megamenu-end";
})(MegaMenuClasses || (MegaMenuClasses = {}));

const MEGAMENU_INSTANCE = new InjectionToken('MEGAMENU_INSTANCE');
const MEGAMENU_SUB_INSTANCE = new InjectionToken('MEGAMENU_SUB_INSTANCE');
class MegaMenuSub extends BaseComponent {
    bindDirectiveInstance = inject(Bind, { self: true });
    $pcMegaMenu = inject(MEGAMENU_INSTANCE, { optional: true, skipSelf: true }) ?? undefined;
    $pcMegaMenuSub = inject(MEGAMENU_SUB_INSTANCE, { optional: true, skipSelf: true }) ?? undefined;
    id;
    items;
    itemTemplate;
    menuId;
    ariaLabel;
    ariaLabelledBy;
    level = 0;
    focusedItemId;
    disabled = false;
    orientation;
    activeItem;
    submenu;
    queryMatches = false;
    mobileActive = false;
    scrollHeight;
    tabindex = 0;
    root = false;
    itemClick = new EventEmitter();
    itemMouseEnter = new EventEmitter();
    menuFocus = new EventEmitter();
    menuBlur = new EventEmitter();
    menuKeydown = new EventEmitter();
    menuMouseDown = new EventEmitter();
    megaMenu = inject(forwardRef(() => MegaMenu));
    _componentStyle = inject(MegaMenuStyle);
    onAfterViewChecked() {
        this.bindDirectiveInstance.setAttrs(this.ptm(this.root ? 'rootList' : 'submenu'));
    }
    onItemClick(event, processedItem) {
        this.getItemProp(processedItem, 'command', { originalEvent: event, item: processedItem.item });
        this.itemClick.emit({ originalEvent: event, processedItem, isFocus: true });
    }
    getItemProp(processedItem, name, params = null) {
        return processedItem && processedItem.item ? resolve(processedItem.item[name], params) : undefined;
    }
    getItemId(processedItem) {
        return processedItem.item && processedItem.item?.id ? processedItem.item.id : `${this.menuId}_${processedItem.key}`;
    }
    getSubListId(processedItem) {
        return `${this.getItemId(processedItem)}_list`;
    }
    getItemLabel(processedItem) {
        return this.getItemProp(processedItem, 'label');
    }
    isSubmenuVisible(submenu) {
        if (this.submenu && !this.root) {
            return this.isItemVisible(submenu);
        }
        else {
            return true;
        }
    }
    isItemVisible(processedItem) {
        return this.getItemProp(processedItem, 'visible') !== false;
    }
    isItemActive(processedItem) {
        return isNotEmpty(this.activeItem) ? this.activeItem.key === processedItem.key : false;
    }
    isItemDisabled(processedItem) {
        return this.getItemProp(processedItem, 'disabled');
    }
    isItemFocused(processedItem) {
        return this.focusedItemId === this.getItemId(processedItem);
    }
    isItemGroup(processedItem) {
        return isNotEmpty(processedItem.items);
    }
    getAriaSetSize() {
        return this.items?.filter((processedItem) => this.isItemVisible(processedItem) && !this.getItemProp(processedItem, 'separator')).length;
    }
    getAriaPosInset(index) {
        return index - (this.items?.slice(0, index).filter((processedItem) => this.isItemVisible(processedItem) && this.getItemProp(processedItem, 'separator')).length || 0) + 1;
    }
    onItemMouseEnter(param) {
        const { event, processedItem } = param;
        this.itemMouseEnter.emit({ originalEvent: event, processedItem });
    }
    getPTOptions(processedItem, index, key) {
        const ptContext = {
            context: {
                item: processedItem.item,
                index,
                active: this.isItemActive(processedItem),
                focused: this.isItemFocused(processedItem),
                disabled: this.isItemDisabled(processedItem)
            }
        };
        return this.ptm(key, ptContext);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.5", ngImport: i0, type: MegaMenuSub, deps: null, target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "21.0.5", type: MegaMenuSub, isStandalone: true, selector: "p-megaMenuSub, p-megamenu-sub, ul[pMegaMenuSub]", inputs: { id: "id", items: "items", itemTemplate: "itemTemplate", menuId: "menuId", ariaLabel: "ariaLabel", ariaLabelledBy: "ariaLabelledBy", level: ["level", "level", numberAttribute], focusedItemId: "focusedItemId", disabled: ["disabled", "disabled", booleanAttribute], orientation: "orientation", activeItem: "activeItem", submenu: "submenu", queryMatches: ["queryMatches", "queryMatches", booleanAttribute], mobileActive: ["mobileActive", "mobileActive", booleanAttribute], scrollHeight: "scrollHeight", tabindex: ["tabindex", "tabindex", numberAttribute], root: ["root", "root", booleanAttribute] }, outputs: { itemClick: "itemClick", itemMouseEnter: "itemMouseEnter", menuFocus: "menuFocus", menuBlur: "menuBlur", menuKeydown: "menuKeydown", menuMouseDown: "menuMouseDown" }, host: { listeners: { "keydown": "menuKeydown.emit($event)", "focus": "menuFocus.emit($event)", "blur": "menuBlur.emit($event)", "mousedown": "menuMouseDown.emit($event)" }, properties: { "class": "root ? cx(\"rootList\") : cx(\"submenu\")", "style": "sx(\"rootList\")", "style.display": "isSubmenuVisible(submenu) ? null : \"none\"", "attr.role": "root ? \"menubar\" : \"menu\"", "attr.id": "id", "attr.aria-orientation": "orientation", "tabindex": "tabindex", "attr.aria-activedescendant": "focusedItemId", "attr.data-pc-section": "root ? \"rootlist\" : \"submenu\"" } }, providers: [
            { provide: MEGAMENU_SUB_INSTANCE, useExisting: MegaMenuSub },
            { provide: PARENT_INSTANCE, useExisting: MegaMenuSub }
        ], usesInheritance: true, hostDirectives: [{ directive: i1.Bind }], ngImport: i0, template: `
        <li *ngIf="submenu" [class]="cn(cx('submenuLabel'), getItemProp(submenu, 'class'))" [style]="getItemProp(submenu, 'style')" role="presentation" [pBind]="ptm('submenuLabel')">
            {{ getItemLabel(submenu) }}
        </li>
        <ng-template ngFor let-processedItem [ngForOf]="items" let-index="index">
            <li
                *ngIf="isItemVisible(processedItem) && getItemProp(processedItem, 'separator')"
                [attr.id]="getItemId(processedItem)"
                [style]="getItemProp(processedItem, 'style')"
                [class]="cn(cx('separator'), this.getItemProp(processedItem, 'class'))"
                role="separator"
                [pBind]="ptm('separator')"
            ></li>
            <li
                #listItem
                *ngIf="isItemVisible(processedItem) && !getItemProp(processedItem, 'separator')"
                role="menuitem"
                [attr.id]="getItemId(processedItem)"
                [attr.data-p-active]="isItemActive(processedItem)"
                [attr.data-p-focused]="isItemFocused(processedItem)"
                [attr.data-p-disabled]="isItemDisabled(processedItem)"
                [attr.aria-label]="getItemLabel(processedItem)"
                [attr.aria-disabled]="isItemDisabled(processedItem) || undefined"
                [attr.aria-haspopup]="isItemGroup(processedItem) && !getItemProp(processedItem, 'to') ? 'menu' : undefined"
                [attr.aria-expanded]="isItemGroup(processedItem) ? isItemActive(processedItem) : undefined"
                [attr.aria-level]="level + 1"
                [attr.aria-setsize]="getAriaSetSize()"
                [attr.aria-posinset]="getAriaPosInset(index)"
                [ngStyle]="getItemProp(processedItem, 'style')"
                [class]="cn(cx('item', { processedItem }), getItemProp(processedItem, 'styleClass'))"
                pTooltip
                [tooltipOptions]="getItemProp(processedItem, 'tooltipOptions')"
                [pBind]="getPTOptions(processedItem, index, 'item')"
                [pTooltipUnstyled]="unstyled()"
            >
                <div [class]="cx('itemContent')" [pBind]="getPTOptions(processedItem, index, 'itemContent')" (click)="onItemClick($event, processedItem)" (mouseenter)="onItemMouseEnter({ $event, processedItem })">
                    <ng-container *ngIf="!itemTemplate">
                        <a
                            *ngIf="!getItemProp(processedItem, 'routerLink')"
                            [attr.href]="getItemProp(processedItem, 'url')"
                            [attr.data-automationid]="getItemProp(processedItem, 'automationId')"
                            [attr.title]="getItemProp(processedItem, 'title')"
                            [target]="getItemProp(processedItem, 'target')"
                            [class]="cn(cx('itemLink'), getItemProp(processedItem, 'linkClass'))"
                            [ngStyle]="getItemProp(processedItem, 'linkStyle')"
                            [attr.tabindex]="-1"
                            [pBind]="getPTOptions(processedItem, index, 'itemLink')"
                            pRipple
                        >
                            <span
                                *ngIf="getItemProp(processedItem, 'icon')"
                                [class]="cn(cx('itemIcon'), getItemProp(processedItem, 'icon'), getItemProp(processedItem, 'iconClass'))"
                                [ngStyle]="getItemProp(processedItem, 'iconStyle')"
                                [attr.tabindex]="-1"
                                [pBind]="getPTOptions(processedItem, index, 'itemIcon')"
                            >
                            </span>
                            <span
                                *ngIf="getItemProp(processedItem, 'escape'); else htmlLabel"
                                [class]="cn(cx('itemLabel'), getItemProp(processedItem, 'labelClass'))"
                                [ngStyle]="getItemProp(processedItem, 'labelStyle')"
                                [pBind]="getPTOptions(processedItem, index, 'itemLabel')"
                            >
                                {{ getItemLabel(processedItem) }}
                            </span>
                            <ng-template #htmlLabel>
                                <span
                                    [class]="cn(cx('itemLabel'), getItemProp(processedItem, 'labelClass'))"
                                    [ngStyle]="getItemProp(processedItem, 'labelStyle')"
                                    [innerHTML]="getItemLabel(processedItem)"
                                    [pBind]="getPTOptions(processedItem, index, 'itemLabel')"
                                ></span>
                            </ng-template>
                            <p-badge *ngIf="getItemProp(processedItem, 'badge')" [class]="getItemProp(processedItem, 'badgeStyleClass')" [value]="getItemProp(processedItem, 'badge')" [unstyled]="unstyled()" />
                            <ng-container *ngIf="isItemGroup(processedItem)">
                                <ng-container *ngIf="!megaMenu.submenuIconTemplate && !megaMenu._submenuIconTemplate">
                                    @if (orientation === 'horizontal' || mobileActive) {
                                        <svg data-p-icon="angle-down" [class]="cx('submenuIcon')" [pBind]="getPTOptions(processedItem, index, 'submenuIcon')" [attr.aria-hidden]="true" />
                                    } @else {
                                        <svg data-p-icon="angle-right" [class]="cx('submenuIcon')" [pBind]="getPTOptions(processedItem, index, 'submenuIcon')" *ngIf="orientation === 'vertical'" [attr.aria-hidden]="true" />
                                    }
                                </ng-container>
                                <ng-template *ngTemplateOutlet="megaMenu.submenuIconTemplate || megaMenu._submenuIconTemplate" [attr.aria-hidden]="true"></ng-template>
                            </ng-container>
                        </a>
                        <a
                            *ngIf="getItemProp(processedItem, 'routerLink')"
                            [routerLink]="getItemProp(processedItem, 'routerLink')"
                            [attr.data-automationid]="getItemProp(processedItem, 'automationId')"
                            [attr.title]="getItemProp(processedItem, 'title')"
                            [attr.tabindex]="-1"
                            [queryParams]="getItemProp(processedItem, 'queryParams')"
                            [routerLinkActive]="'p-megamenu-item-link-active'"
                            [routerLinkActiveOptions]="getItemProp(processedItem, 'routerLinkActiveOptions') || { exact: false }"
                            [target]="getItemProp(processedItem, 'target')"
                            [class]="cn(cx('itemLink'), getItemProp(processedItem, 'linkClass'))"
                            [ngStyle]="getItemProp(processedItem, 'linkStyle')"
                            [fragment]="getItemProp(processedItem, 'fragment')"
                            [queryParamsHandling]="getItemProp(processedItem, 'queryParamsHandling')"
                            [preserveFragment]="getItemProp(processedItem, 'preserveFragment')"
                            [skipLocationChange]="getItemProp(processedItem, 'skipLocationChange')"
                            [replaceUrl]="getItemProp(processedItem, 'replaceUrl')"
                            [state]="getItemProp(processedItem, 'state')"
                            [pBind]="getPTOptions(processedItem, index, 'itemLink')"
                            pRipple
                        >
                            <span
                                [class]="cn(cx('itemIcon'), getItemProp(processedItem, 'icon'), getItemProp(processedItem, 'iconClass'))"
                                *ngIf="getItemProp(processedItem, 'icon')"
                                [ngStyle]="getItemProp(processedItem, 'iconStyle')"
                                [attr.tabindex]="-1"
                                [pBind]="getPTOptions(processedItem, index, 'itemIcon')"
                            ></span>
                            <span
                                [class]="cn(cx('itemLabel'), getItemProp(processedItem, 'labelClass'))"
                                [ngStyle]="getItemProp(processedItem, 'labelStyle')"
                                *ngIf="getItemProp(processedItem, 'escape'); else htmlRouteLabel"
                                [pBind]="getPTOptions(processedItem, index, 'itemLabel')"
                                >{{ getItemLabel(processedItem) }}</span
                            >
                            <ng-template #htmlRouteLabel
                                ><span
                                    [class]="cn(cx('itemLabel'), getItemProp(processedItem, 'labelClass'))"
                                    [ngStyle]="getItemProp(processedItem, 'labelStyle')"
                                    [innerHTML]="getItemLabel(processedItem)"
                                    [pBind]="getPTOptions(processedItem, index, 'itemLabel')"
                                ></span
                            ></ng-template>
                            <p-badge *ngIf="getItemProp(processedItem, 'badge')" [styleClass]="getItemProp(processedItem, 'badgeStyleClass')" [value]="getItemProp(processedItem, 'badge')" [unstyled]="unstyled()" />
                            <ng-container *ngIf="isItemGroup(processedItem)">
                                <ng-container *ngIf="!megaMenu.submenuIconTemplate && !megaMenu._submenuIconTemplate">
                                    <svg data-p-icon="angle-down" [class]="cx('submenuIcon')" [pBind]="getPTOptions(processedItem, index, 'submenuIcon')" *ngIf="orientation === 'horizontal'" [attr.aria-hidden]="true" />
                                    <svg data-p-icon="angle-right" [class]="cx('submenuIcon')" [pBind]="getPTOptions(processedItem, index, 'submenuIcon')" *ngIf="orientation === 'vertical'" [attr.aria-hidden]="true" />
                                </ng-container>
                                <ng-template *ngTemplateOutlet="megaMenu.submenuIconTemplate || megaMenu._submenuIconTemplate" [attr.aria-hidden]="true"></ng-template>
                            </ng-container>
                        </a>
                    </ng-container>
                    <ng-container *ngIf="itemTemplate">
                        <ng-template *ngTemplateOutlet="itemTemplate; context: { $implicit: processedItem.item }"></ng-template>
                    </ng-container>
                </div>
                <div *ngIf="isItemVisible(processedItem) && isItemGroup(processedItem)" [class]="cx('overlay')" [pBind]="ptm('overlay')">
                    <div [class]="cx('grid')" [pBind]="ptm('grid')">
                        <div *ngFor="let col of processedItem.items" [class]="cx('column', { processedItem })" [pBind]="ptm('column')">
                            <ul
                                pMegaMenuSub
                                *ngFor="let submenu of col"
                                [id]="getSubListId(submenu)"
                                [submenu]="submenu"
                                [items]="submenu.items"
                                [itemTemplate]="itemTemplate"
                                [mobileActive]="mobileActive"
                                [menuId]="menuId"
                                [focusedItemId]="focusedItemId"
                                [level]="level + 1"
                                [root]="false"
                                (itemClick)="itemClick.emit($event)"
                                (itemMouseEnter)="onItemMouseEnter($event)"
                                [pt]="pt()"
                                [unstyled]="unstyled()"
                            ></ul>
                        </div>
                    </div>
                </div>
            </li>
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "component", type: MegaMenuSub, selector: "p-megaMenuSub, p-megamenu-sub, ul[pMegaMenuSub]", inputs: ["id", "items", "itemTemplate", "menuId", "ariaLabel", "ariaLabelledBy", "level", "focusedItemId", "disabled", "orientation", "activeItem", "submenu", "queryMatches", "mobileActive", "scrollHeight", "tabindex", "root"], outputs: ["itemClick", "itemMouseEnter", "menuFocus", "menuBlur", "menuKeydown", "menuMouseDown"] }, { kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i2.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "ngmodule", type: RouterModule }, { kind: "directive", type: i3.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "info", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "directive", type: i3.RouterLinkActive, selector: "[routerLinkActive]", inputs: ["routerLinkActiveOptions", "ariaCurrentWhenActive", "routerLinkActive"], outputs: ["isActiveChange"], exportAs: ["routerLinkActive"] }, { kind: "directive", type: Ripple, selector: "[pRipple]" }, { kind: "ngmodule", type: TooltipModule }, { kind: "directive", type: i4.Tooltip, selector: "[pTooltip]", inputs: ["tooltipPosition", "tooltipEvent", "positionStyle", "tooltipStyleClass", "tooltipZIndex", "escape", "showDelay", "hideDelay", "life", "positionTop", "positionLeft", "autoHide", "fitContent", "hideOnEscape", "pTooltip", "tooltipDisabled", "tooltipOptions", "appendTo", "ptTooltip", "pTooltipPT", "pTooltipUnstyled"] }, { kind: "directive", type: i1.Bind, selector: "[pBind]", inputs: ["pBind"] }, { kind: "component", type: AngleDownIcon, selector: "[data-p-icon=\"angle-down\"]" }, { kind: "component", type: AngleRightIcon, selector: "[data-p-icon=\"angle-right\"]" }, { kind: "ngmodule", type: BadgeModule }, { kind: "component", type: i5.Badge, selector: "p-badge", inputs: ["styleClass", "badgeSize", "size", "severity", "value", "badgeDisabled"] }, { kind: "ngmodule", type: SharedModule }], encapsulation: i0.ViewEncapsulation.None });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.5", ngImport: i0, type: MegaMenuSub, decorators: [{
            type: Component,
            args: [{
                    selector: 'p-megaMenuSub, p-megamenu-sub, ul[pMegaMenuSub]',
                    standalone: true,
                    imports: [CommonModule, RouterModule, Ripple, TooltipModule, AngleDownIcon, AngleRightIcon, BadgeModule, SharedModule, Bind],
                    template: `
        <li *ngIf="submenu" [class]="cn(cx('submenuLabel'), getItemProp(submenu, 'class'))" [style]="getItemProp(submenu, 'style')" role="presentation" [pBind]="ptm('submenuLabel')">
            {{ getItemLabel(submenu) }}
        </li>
        <ng-template ngFor let-processedItem [ngForOf]="items" let-index="index">
            <li
                *ngIf="isItemVisible(processedItem) && getItemProp(processedItem, 'separator')"
                [attr.id]="getItemId(processedItem)"
                [style]="getItemProp(processedItem, 'style')"
                [class]="cn(cx('separator'), this.getItemProp(processedItem, 'class'))"
                role="separator"
                [pBind]="ptm('separator')"
            ></li>
            <li
                #listItem
                *ngIf="isItemVisible(processedItem) && !getItemProp(processedItem, 'separator')"
                role="menuitem"
                [attr.id]="getItemId(processedItem)"
                [attr.data-p-active]="isItemActive(processedItem)"
                [attr.data-p-focused]="isItemFocused(processedItem)"
                [attr.data-p-disabled]="isItemDisabled(processedItem)"
                [attr.aria-label]="getItemLabel(processedItem)"
                [attr.aria-disabled]="isItemDisabled(processedItem) || undefined"
                [attr.aria-haspopup]="isItemGroup(processedItem) && !getItemProp(processedItem, 'to') ? 'menu' : undefined"
                [attr.aria-expanded]="isItemGroup(processedItem) ? isItemActive(processedItem) : undefined"
                [attr.aria-level]="level + 1"
                [attr.aria-setsize]="getAriaSetSize()"
                [attr.aria-posinset]="getAriaPosInset(index)"
                [ngStyle]="getItemProp(processedItem, 'style')"
                [class]="cn(cx('item', { processedItem }), getItemProp(processedItem, 'styleClass'))"
                pTooltip
                [tooltipOptions]="getItemProp(processedItem, 'tooltipOptions')"
                [pBind]="getPTOptions(processedItem, index, 'item')"
                [pTooltipUnstyled]="unstyled()"
            >
                <div [class]="cx('itemContent')" [pBind]="getPTOptions(processedItem, index, 'itemContent')" (click)="onItemClick($event, processedItem)" (mouseenter)="onItemMouseEnter({ $event, processedItem })">
                    <ng-container *ngIf="!itemTemplate">
                        <a
                            *ngIf="!getItemProp(processedItem, 'routerLink')"
                            [attr.href]="getItemProp(processedItem, 'url')"
                            [attr.data-automationid]="getItemProp(processedItem, 'automationId')"
                            [attr.title]="getItemProp(processedItem, 'title')"
                            [target]="getItemProp(processedItem, 'target')"
                            [class]="cn(cx('itemLink'), getItemProp(processedItem, 'linkClass'))"
                            [ngStyle]="getItemProp(processedItem, 'linkStyle')"
                            [attr.tabindex]="-1"
                            [pBind]="getPTOptions(processedItem, index, 'itemLink')"
                            pRipple
                        >
                            <span
                                *ngIf="getItemProp(processedItem, 'icon')"
                                [class]="cn(cx('itemIcon'), getItemProp(processedItem, 'icon'), getItemProp(processedItem, 'iconClass'))"
                                [ngStyle]="getItemProp(processedItem, 'iconStyle')"
                                [attr.tabindex]="-1"
                                [pBind]="getPTOptions(processedItem, index, 'itemIcon')"
                            >
                            </span>
                            <span
                                *ngIf="getItemProp(processedItem, 'escape'); else htmlLabel"
                                [class]="cn(cx('itemLabel'), getItemProp(processedItem, 'labelClass'))"
                                [ngStyle]="getItemProp(processedItem, 'labelStyle')"
                                [pBind]="getPTOptions(processedItem, index, 'itemLabel')"
                            >
                                {{ getItemLabel(processedItem) }}
                            </span>
                            <ng-template #htmlLabel>
                                <span
                                    [class]="cn(cx('itemLabel'), getItemProp(processedItem, 'labelClass'))"
                                    [ngStyle]="getItemProp(processedItem, 'labelStyle')"
                                    [innerHTML]="getItemLabel(processedItem)"
                                    [pBind]="getPTOptions(processedItem, index, 'itemLabel')"
                                ></span>
                            </ng-template>
                            <p-badge *ngIf="getItemProp(processedItem, 'badge')" [class]="getItemProp(processedItem, 'badgeStyleClass')" [value]="getItemProp(processedItem, 'badge')" [unstyled]="unstyled()" />
                            <ng-container *ngIf="isItemGroup(processedItem)">
                                <ng-container *ngIf="!megaMenu.submenuIconTemplate && !megaMenu._submenuIconTemplate">
                                    @if (orientation === 'horizontal' || mobileActive) {
                                        <svg data-p-icon="angle-down" [class]="cx('submenuIcon')" [pBind]="getPTOptions(processedItem, index, 'submenuIcon')" [attr.aria-hidden]="true" />
                                    } @else {
                                        <svg data-p-icon="angle-right" [class]="cx('submenuIcon')" [pBind]="getPTOptions(processedItem, index, 'submenuIcon')" *ngIf="orientation === 'vertical'" [attr.aria-hidden]="true" />
                                    }
                                </ng-container>
                                <ng-template *ngTemplateOutlet="megaMenu.submenuIconTemplate || megaMenu._submenuIconTemplate" [attr.aria-hidden]="true"></ng-template>
                            </ng-container>
                        </a>
                        <a
                            *ngIf="getItemProp(processedItem, 'routerLink')"
                            [routerLink]="getItemProp(processedItem, 'routerLink')"
                            [attr.data-automationid]="getItemProp(processedItem, 'automationId')"
                            [attr.title]="getItemProp(processedItem, 'title')"
                            [attr.tabindex]="-1"
                            [queryParams]="getItemProp(processedItem, 'queryParams')"
                            [routerLinkActive]="'p-megamenu-item-link-active'"
                            [routerLinkActiveOptions]="getItemProp(processedItem, 'routerLinkActiveOptions') || { exact: false }"
                            [target]="getItemProp(processedItem, 'target')"
                            [class]="cn(cx('itemLink'), getItemProp(processedItem, 'linkClass'))"
                            [ngStyle]="getItemProp(processedItem, 'linkStyle')"
                            [fragment]="getItemProp(processedItem, 'fragment')"
                            [queryParamsHandling]="getItemProp(processedItem, 'queryParamsHandling')"
                            [preserveFragment]="getItemProp(processedItem, 'preserveFragment')"
                            [skipLocationChange]="getItemProp(processedItem, 'skipLocationChange')"
                            [replaceUrl]="getItemProp(processedItem, 'replaceUrl')"
                            [state]="getItemProp(processedItem, 'state')"
                            [pBind]="getPTOptions(processedItem, index, 'itemLink')"
                            pRipple
                        >
                            <span
                                [class]="cn(cx('itemIcon'), getItemProp(processedItem, 'icon'), getItemProp(processedItem, 'iconClass'))"
                                *ngIf="getItemProp(processedItem, 'icon')"
                                [ngStyle]="getItemProp(processedItem, 'iconStyle')"
                                [attr.tabindex]="-1"
                                [pBind]="getPTOptions(processedItem, index, 'itemIcon')"
                            ></span>
                            <span
                                [class]="cn(cx('itemLabel'), getItemProp(processedItem, 'labelClass'))"
                                [ngStyle]="getItemProp(processedItem, 'labelStyle')"
                                *ngIf="getItemProp(processedItem, 'escape'); else htmlRouteLabel"
                                [pBind]="getPTOptions(processedItem, index, 'itemLabel')"
                                >{{ getItemLabel(processedItem) }}</span
                            >
                            <ng-template #htmlRouteLabel
                                ><span
                                    [class]="cn(cx('itemLabel'), getItemProp(processedItem, 'labelClass'))"
                                    [ngStyle]="getItemProp(processedItem, 'labelStyle')"
                                    [innerHTML]="getItemLabel(processedItem)"
                                    [pBind]="getPTOptions(processedItem, index, 'itemLabel')"
                                ></span
                            ></ng-template>
                            <p-badge *ngIf="getItemProp(processedItem, 'badge')" [styleClass]="getItemProp(processedItem, 'badgeStyleClass')" [value]="getItemProp(processedItem, 'badge')" [unstyled]="unstyled()" />
                            <ng-container *ngIf="isItemGroup(processedItem)">
                                <ng-container *ngIf="!megaMenu.submenuIconTemplate && !megaMenu._submenuIconTemplate">
                                    <svg data-p-icon="angle-down" [class]="cx('submenuIcon')" [pBind]="getPTOptions(processedItem, index, 'submenuIcon')" *ngIf="orientation === 'horizontal'" [attr.aria-hidden]="true" />
                                    <svg data-p-icon="angle-right" [class]="cx('submenuIcon')" [pBind]="getPTOptions(processedItem, index, 'submenuIcon')" *ngIf="orientation === 'vertical'" [attr.aria-hidden]="true" />
                                </ng-container>
                                <ng-template *ngTemplateOutlet="megaMenu.submenuIconTemplate || megaMenu._submenuIconTemplate" [attr.aria-hidden]="true"></ng-template>
                            </ng-container>
                        </a>
                    </ng-container>
                    <ng-container *ngIf="itemTemplate">
                        <ng-template *ngTemplateOutlet="itemTemplate; context: { $implicit: processedItem.item }"></ng-template>
                    </ng-container>
                </div>
                <div *ngIf="isItemVisible(processedItem) && isItemGroup(processedItem)" [class]="cx('overlay')" [pBind]="ptm('overlay')">
                    <div [class]="cx('grid')" [pBind]="ptm('grid')">
                        <div *ngFor="let col of processedItem.items" [class]="cx('column', { processedItem })" [pBind]="ptm('column')">
                            <ul
                                pMegaMenuSub
                                *ngFor="let submenu of col"
                                [id]="getSubListId(submenu)"
                                [submenu]="submenu"
                                [items]="submenu.items"
                                [itemTemplate]="itemTemplate"
                                [mobileActive]="mobileActive"
                                [menuId]="menuId"
                                [focusedItemId]="focusedItemId"
                                [level]="level + 1"
                                [root]="false"
                                (itemClick)="itemClick.emit($event)"
                                (itemMouseEnter)="onItemMouseEnter($event)"
                                [pt]="pt()"
                                [unstyled]="unstyled()"
                            ></ul>
                        </div>
                    </div>
                </div>
            </li>
        </ng-template>
    `,
                    encapsulation: ViewEncapsulation.None,
                    providers: [
                        { provide: MEGAMENU_SUB_INSTANCE, useExisting: MegaMenuSub },
                        { provide: PARENT_INSTANCE, useExisting: MegaMenuSub }
                    ],
                    host: {
                        '[class]': 'root ? cx("rootList") : cx("submenu")',
                        '[style]': 'sx("rootList")',
                        '[style.display]': 'isSubmenuVisible(submenu) ? null : "none"',
                        '[attr.role]': 'root ? "menubar" : "menu"',
                        '[attr.id]': 'id',
                        '[attr.aria-orientation]': 'orientation',
                        '[tabindex]': 'tabindex',
                        '[attr.aria-activedescendant]': 'focusedItemId',
                        '[attr.data-pc-section]': 'root ? "rootlist" : "submenu"',
                        '(keydown)': 'menuKeydown.emit($event)',
                        '(focus)': 'menuFocus.emit($event)',
                        '(blur)': 'menuBlur.emit($event)',
                        '(mousedown)': 'menuMouseDown.emit($event)'
                    },
                    hostDirectives: [Bind]
                }]
        }], propDecorators: { id: [{
                type: Input
            }], items: [{
                type: Input
            }], itemTemplate: [{
                type: Input
            }], menuId: [{
                type: Input
            }], ariaLabel: [{
                type: Input
            }], ariaLabelledBy: [{
                type: Input
            }], level: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], focusedItemId: [{
                type: Input
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], orientation: [{
                type: Input
            }], activeItem: [{
                type: Input
            }], submenu: [{
                type: Input
            }], queryMatches: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], mobileActive: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], scrollHeight: [{
                type: Input
            }], tabindex: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], root: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], itemClick: [{
                type: Output
            }], itemMouseEnter: [{
                type: Output
            }], menuFocus: [{
                type: Output
            }], menuBlur: [{
                type: Output
            }], menuKeydown: [{
                type: Output
            }], menuMouseDown: [{
                type: Output
            }] } });
/**
 * MegaMenu is navigation component that displays submenus together.
 * @group Components
 */
class MegaMenu extends BaseComponent {
    bindDirectiveInstance = inject(Bind, { self: true });
    /**
     * An array of menuitems.
     * @group Props
     */
    set model(value) {
        this._model = value;
        this._processedItems = this.createProcessedItems(this._model || []);
    }
    get model() {
        return this._model;
    }
    /**
     * Class of the element.
     * @deprecated since v20.0.0, use `class` instead.
     * @group Props
     */
    styleClass;
    /**
     * Defines the orientation.
     * @group Props
     */
    orientation = 'horizontal';
    /**
     * Current id state as a string.
     * @group Props
     */
    id;
    /**
     * Defines a string value that labels an interactive element.
     * @group Props
     */
    ariaLabel;
    /**
     * Identifier of the underlying input element.
     * @group Props
     */
    ariaLabelledBy;
    /**
     * The breakpoint to define the maximum width boundary.
     * @group Props
     */
    breakpoint = '960px';
    /**
     * Height of the viewport, a scrollbar is defined if height of list exceeds this value.
     * @group Props
     */
    scrollHeight = '20rem';
    /**
     * When present, it specifies that the component should be disabled.
     * @group Props
     */
    disabled = false;
    /**
     * Index of the element in tabbing order.
     * @group Props
     */
    tabindex = 0;
    /**
     * Defines template option for start.
     * @group Templates
     */
    startTemplate;
    /**
     * Defines template option for end.
     * @group Templates
     */
    endTemplate;
    /**
     * Defines template option for menu icon.
     * @group Templates
     */
    menuIconTemplate;
    /**
     * Defines template option for submenu icon.
     * @group Templates
     */
    submenuIconTemplate;
    /**
     * Custom item template.
     * @param {MegaMenuItemTemplateContext} context - item context.
     * @see {@link MegaMenuItemTemplateContext}
     * @group Templates
     */
    itemTemplate;
    /**
     * Custom menu button template on responsive mode.
     * @group Templates
     */
    buttonTemplate;
    /**
     * Custom menu button icon template on responsive mode.
     * @group Templates
     */
    buttonIconTemplate;
    templates;
    menubuttonViewChild;
    rootmenu;
    _startTemplate;
    _endTemplate;
    _menuIconTemplate;
    _submenuIconTemplate;
    _itemTemplate;
    _buttonTemplate;
    _buttonIconTemplate;
    outsideClickListener;
    resizeListener;
    dirty = false;
    focused = false;
    activeItem = signal(null, ...(ngDevMode ? [{ debugName: "activeItem" }] : []));
    focusedItemInfo = signal({ index: -1, level: 0, parentKey: '', item: null }, ...(ngDevMode ? [{ debugName: "focusedItemInfo" }] : []));
    searchValue = '';
    searchTimeout;
    _processedItems;
    _model;
    _componentStyle = inject(MegaMenuStyle);
    matchMediaListener;
    query;
    queryMatches = signal(false, ...(ngDevMode ? [{ debugName: "queryMatches" }] : []));
    mobileActive = false;
    get visibleItems() {
        const processedItem = isNotEmpty(this.activeItem()) ? this.activeItem() : null;
        return processedItem
            ? processedItem.items.reduce((items, col) => {
                col.forEach((submenu) => {
                    submenu.items.forEach((a) => {
                        items.push(a);
                    });
                });
                return items;
            }, [])
            : this.processedItems;
    }
    get processedItems() {
        if (!this._processedItems || !this._processedItems.length) {
            this._processedItems = this.createProcessedItems(this.model || []);
        }
        return this._processedItems;
    }
    get focusedItemId() {
        const focusedItem = this.focusedItemInfo();
        return focusedItem?.item && focusedItem.item?.id ? focusedItem.item.id : isNotEmpty(focusedItem.key) ? `${this.id}_${focusedItem.key}` : null;
    }
    constructor() {
        super();
        effect(() => {
            const activeItem = this.activeItem();
            if (isNotEmpty(activeItem)) {
                this.bindOutsideClickListener();
                this.bindResizeListener();
            }
            else {
                this.unbindOutsideClickListener();
                this.unbindResizeListener();
            }
        });
    }
    onInit() {
        this.bindMatchMediaListener();
        this.id = this.id || uuid('pn_id_');
    }
    onAfterViewChecked() {
        this.bindDirectiveInstance.setAttrs(this.ptms(['host', 'root']));
    }
    onAfterContentInit() {
        this.templates?.forEach((item) => {
            switch (item.getType()) {
                case 'start':
                    this._startTemplate = item.template;
                    break;
                case 'end':
                    this._endTemplate = item.template;
                    break;
                case 'menuicon':
                    this._menuIconTemplate = item.template;
                    break;
                case 'submenuicon':
                    this._submenuIconTemplate = item.template;
                    break;
                case 'item':
                    this._itemTemplate = item.template;
                    break;
                case 'button':
                    this._buttonTemplate = item.template;
                    break;
                case 'buttonicon':
                    this._buttonIconTemplate = item.template;
                    break;
                default:
                    this._itemTemplate = item.template;
                    break;
            }
        });
    }
    bindMatchMediaListener() {
        if (isPlatformBrowser(this.platformId)) {
            if (!this.matchMediaListener) {
                const query = window.matchMedia(`(max-width: ${this.breakpoint})`);
                this.query = query;
                this.queryMatches.set(query.matches);
                this.matchMediaListener = () => {
                    this.queryMatches.set(query.matches);
                    this.mobileActive = false;
                    this.cd.markForCheck();
                };
                query.addEventListener('change', this.matchMediaListener);
            }
        }
    }
    unbindMatchMediaListener() {
        if (this.matchMediaListener) {
            this.query.removeEventListener('change', this.matchMediaListener);
            this.matchMediaListener = null;
        }
    }
    createProcessedItems(items, level = 0, parent = {}, parentKey = '', columnIndex) {
        const processedItems = [];
        items &&
            items.forEach((item, index) => {
                const key = (parentKey !== '' ? parentKey + '_' : '') + (columnIndex !== undefined ? columnIndex + '_' : '') + index;
                const newItem = {
                    item,
                    index,
                    level,
                    key,
                    parent,
                    parentKey,
                    columnIndex: columnIndex !== undefined ? columnIndex : parent.columnIndex !== undefined ? parent.columnIndex : index
                };
                newItem['items'] =
                    level === 0 && item.items && item.items.length > 0
                        ? item.items.map((_items, _index) => this.createProcessedItems(_items, level + 1, newItem, key, _index))
                        : this.createProcessedItems(item.items, level + 1, newItem, key);
                processedItems.push(newItem);
            });
        return processedItems;
    }
    getItemProp(item, name) {
        return item ? resolve(item[name]) : undefined;
    }
    onItemClick(event) {
        this.dirty = true;
        const { originalEvent, processedItem } = event;
        const grouped = this.isProcessedItemGroup(processedItem);
        const root = isEmpty(processedItem.parent);
        const selected = this.isSelected(processedItem);
        if (selected) {
            const { index, key, parentKey, item } = processedItem;
            this.activeItem.set(null);
            this.focusedItemInfo.set({ index, key, parentKey, item });
            this.dirty = !root;
            if (!this.mobileActive) {
                focus(this.rootmenu?.el?.nativeElement, { preventScroll: true });
            }
        }
        else {
            if (grouped) {
                this.onItemChange(event);
            }
            else {
                this.hide(originalEvent);
            }
        }
    }
    onItemMouseEnter(event) {
        if (!this.mobileActive && this.dirty) {
            this.onItemChange(event);
        }
    }
    menuButtonClick(event) {
        this.toggle(event);
    }
    menuButtonKeydown(event) {
        (event.code === 'Enter' || event.code === 'NumpadEnter' || event.code === 'Space') && this.menuButtonClick(event);
    }
    toggle(event) {
        if (this.mobileActive) {
            this.mobileActive = false;
            ZIndexUtils.clear(this.rootmenu?.el.nativeElement);
            this.hide();
        }
        else {
            this.mobileActive = true;
            ZIndexUtils.set('menu', this.rootmenu?.el.nativeElement, this.config.zIndex.menu);
            setTimeout(() => {
                this.show();
            }, 0);
        }
        this.bindOutsideClickListener();
        event.preventDefault();
    }
    show() {
        this.focusedItemInfo.set({ index: this.findFirstFocusedItemIndex(), level: 0, parentKey: '' });
        focus(this.rootmenu?.el.nativeElement);
    }
    scrollInView(index = -1) {
        const id = index !== -1 ? `${this.id}_${index}` : this.focusedItemId;
        let element;
        if (id === null && this.queryMatches()) {
            element = this.menubuttonViewChild?.nativeElement;
        }
        else {
            element = findSingle(this.rootmenu?.el?.nativeElement, `li[id="${id}"]`);
        }
        if (element) {
            element.scrollIntoView && element.scrollIntoView({ block: 'nearest', inline: 'nearest', behavior: 'smooth' });
        }
    }
    onItemChange(event) {
        const { processedItem, isFocus } = event;
        if (isEmpty(processedItem))
            return;
        const { index, key, parentKey, items, item } = processedItem;
        const grouped = isNotEmpty(items);
        if (grouped) {
            this.activeItem.set(processedItem);
        }
        this.focusedItemInfo.set({ index, key, parentKey, item });
        grouped && (this.dirty = true);
        isFocus && focus(this.rootmenu?.el?.nativeElement);
    }
    hide(event, isFocus) {
        if (this.mobileActive) {
            this.mobileActive = false;
            setTimeout(() => {
                focus(this.menubuttonViewChild?.nativeElement);
                this.scrollInView();
            }, 100);
        }
        this.activeItem.set(null);
        this.focusedItemInfo.set({ index: -1, key: '', parentKey: '', item: null });
        isFocus && focus(this.rootmenu?.el?.nativeElement);
        this.dirty = false;
    }
    onMenuMouseDown(event) {
        this.dirty = true;
    }
    onMenuFocus(event) {
        this.focused = true;
        const relatedTarget = event.relatedTarget;
        const isFromOutside = !relatedTarget || !this.el.nativeElement.contains(relatedTarget);
        if (isFromOutside && this.focusedItemInfo().index === -1 && isEmpty(this.activeItem()) && !this.dirty) {
            const index = this.findFirstFocusedItemIndex();
            const processedItem = this.findVisibleItem(index);
            this.focusedItemInfo.set({ index, key: processedItem.key, parentKey: processedItem.parentKey, item: processedItem.item });
        }
    }
    onMenuBlur(event) {
        const relatedTarget = event.relatedTarget;
        if (relatedTarget && this.el.nativeElement.contains(relatedTarget)) {
            return;
        }
        setTimeout(() => {
            const activeElement = this.document.activeElement;
            if (activeElement && this.el.nativeElement.contains(activeElement)) {
                return;
            }
            this.focused = false;
            this.focusedItemInfo.set({ index: -1, level: 0, parentKey: '', item: null });
            this.searchValue = '';
            this.dirty = false;
        });
    }
    onKeyDown(event) {
        const metaKey = event.metaKey || event.ctrlKey;
        switch (event.code) {
            case 'ArrowDown':
                this.onArrowDownKey(event);
                break;
            case 'ArrowUp':
                this.onArrowUpKey(event);
                break;
            case 'ArrowLeft':
                this.onArrowLeftKey(event);
                break;
            case 'ArrowRight':
                this.onArrowRightKey(event);
                break;
            case 'Home':
                this.onHomeKey(event);
                break;
            case 'End':
                this.onEndKey(event);
                break;
            case 'Space':
                this.onSpaceKey(event);
                break;
            case 'Enter':
                this.onEnterKey(event);
                break;
            case 'Escape':
                this.onEscapeKey(event);
                break;
            case 'Tab':
                this.onTabKey(event);
                break;
            case 'PageDown':
            case 'PageUp':
            case 'Backspace':
            case 'ShiftLeft':
            case 'ShiftRight':
                //NOOP
                break;
            default:
                if (!metaKey && isPrintableCharacter(event.key)) {
                    this.searchItems(event, event.key);
                }
                break;
        }
    }
    findFirstFocusedItemIndex() {
        const selectedIndex = this.findSelectedItemIndex();
        return selectedIndex < 0 ? this.findFirstItemIndex() : selectedIndex;
    }
    findFirstItemIndex() {
        return this.visibleItems.findIndex((processedItem) => this.isValidItem(processedItem));
    }
    findSelectedItemIndex() {
        return this.visibleItems.findIndex((processedItem) => this.isValidSelectedItem(processedItem));
    }
    isProcessedItemGroup(processedItem) {
        return processedItem && isNotEmpty(processedItem.items);
    }
    isSelected(processedItem) {
        return isNotEmpty(this.activeItem()) ? this.activeItem().key === processedItem.key : false;
    }
    isValidSelectedItem(processedItem) {
        return this.isValidItem(processedItem) && this.isSelected(processedItem);
    }
    isValidItem(processedItem) {
        return !!processedItem && !this.isItemDisabled(processedItem.item) && !this.isItemSeparator(processedItem.item);
    }
    isItemDisabled(item) {
        return this.getItemProp(item, 'disabled');
    }
    isItemSeparator(item) {
        return this.getItemProp(item, 'separator');
    }
    isItemMatched(processedItem) {
        return this.isValidItem(processedItem) && this.getProccessedItemLabel(processedItem).toLocaleLowerCase().startsWith(this.searchValue.toLocaleLowerCase());
    }
    isProccessedItemGroup(processedItem) {
        return processedItem && isNotEmpty(processedItem.items);
    }
    searchItems(event, char) {
        this.searchValue = (this.searchValue || '') + char;
        let itemIndex = -1;
        let matched = false;
        if (this.focusedItemInfo().index !== -1) {
            itemIndex = this.visibleItems.slice(this.focusedItemInfo().index).findIndex((processedItem) => this.isItemMatched(processedItem));
            itemIndex = itemIndex === -1 ? this.visibleItems.slice(0, this.focusedItemInfo().index).findIndex((processedItem) => this.isItemMatched(processedItem)) : itemIndex + this.focusedItemInfo().index;
        }
        else {
            itemIndex = this.visibleItems.findIndex((processedItem) => this.isItemMatched(processedItem));
        }
        if (itemIndex !== -1) {
            matched = true;
        }
        if (itemIndex === -1 && this.focusedItemInfo().index === -1) {
            itemIndex = this.findFirstFocusedItemIndex();
        }
        if (itemIndex !== -1) {
            this.changeFocusedItemInfo(event, itemIndex);
        }
        if (this.searchTimeout) {
            clearTimeout(this.searchTimeout);
        }
        this.searchTimeout = setTimeout(() => {
            this.searchValue = '';
            this.searchTimeout = null;
        }, 500);
        return matched;
    }
    getProccessedItemLabel(processedItem) {
        return processedItem ? this.getItemLabel(processedItem.item) : undefined;
    }
    getItemLabel(item) {
        return this.getItemProp(item, 'label');
    }
    changeFocusedItemInfo(event, index) {
        const processedItem = this.findVisibleItem(index);
        if (isNotEmpty(processedItem)) {
            const { key, parentKey, item } = processedItem;
            this.focusedItemInfo.set({ index, key: key ? key : '', parentKey, item });
        }
        this.scrollInView();
    }
    onArrowDownKey(event) {
        if (this.orientation === 'horizontal') {
            if (isNotEmpty(this.activeItem()) && this.activeItem().key === this.focusedItemInfo().key) {
                const { key, item } = this.activeItem();
                this.focusedItemInfo.set({ index: -1, key: '', parentKey: key, item });
            }
            else {
                const processedItem = this.findVisibleItem(this.focusedItemInfo().index);
                const grouped = this.isProccessedItemGroup(processedItem);
                if (grouped) {
                    const { parentKey, key, item } = processedItem;
                    this.onItemChange({ originalEvent: event, processedItem });
                    this.focusedItemInfo.set({ index: -1, key: key, parentKey: parentKey, item: item });
                    this.searchValue = '';
                }
            }
        }
        const itemIndex = this.focusedItemInfo().index !== -1 ? this.findNextItemIndex(this.focusedItemInfo().index) : this.findFirstFocusedItemIndex();
        this.changeFocusedItemInfo(event, itemIndex);
        event.preventDefault();
    }
    onArrowRightKey(event) {
        const processedItem = this.findVisibleItem(this.focusedItemInfo().index);
        const grouped = this.isProccessedItemGroup(processedItem);
        if (grouped) {
            if (this.orientation === 'vertical') {
                if (isNotEmpty(this.activeItem()) && this.activeItem().key === processedItem.key) {
                    this.focusedItemInfo.set({ index: -1, key: '', parentKey: this.activeItem().key, item: processedItem.item });
                }
                else {
                    const processedItem = this.findVisibleItem(this.focusedItemInfo().index);
                    const grouped = this.isProccessedItemGroup(processedItem);
                    if (grouped) {
                        this.onItemChange({ originalEvent: event, processedItem });
                        this.focusedItemInfo.set({
                            index: -1,
                            key: processedItem.key,
                            parentKey: processedItem.parentKey,
                            item: processedItem.item
                        });
                        this.searchValue = '';
                    }
                }
            }
            const itemIndex = this.focusedItemInfo().index !== -1 ? this.findNextItemIndex(this.focusedItemInfo().index) : this.findFirstFocusedItemIndex();
            this.changeFocusedItemInfo(event, itemIndex);
        }
        else {
            const columnIndex = processedItem.columnIndex + 1;
            const itemIndex = this.visibleItems.findIndex((item) => item.columnIndex === columnIndex);
            itemIndex !== -1 && this.changeFocusedItemInfo(event, itemIndex);
        }
        event.preventDefault();
    }
    onArrowUpKey(event) {
        if (event.altKey && this.orientation === 'horizontal') {
            if (this.focusedItemInfo().index !== -1) {
                const processedItem = this.findVisibleItem(this.focusedItemInfo().index);
                const grouped = this.isProccessedItemGroup(processedItem);
                if (!grouped && isNotEmpty(this.activeItem)) {
                    if (this.focusedItemInfo().index === 0) {
                        this.focusedItemInfo.set({
                            index: this.activeItem().index,
                            key: this.activeItem().key,
                            parentKey: this.activeItem().parentKey,
                            item: processedItem.item
                        });
                        this.activeItem.set(null);
                    }
                    else {
                        this.changeFocusedItemInfo(event, this.findFirstItemIndex());
                    }
                }
            }
            event.preventDefault();
        }
        else {
            const itemIndex = this.focusedItemInfo().index !== -1 ? this.findPrevItemIndex(this.focusedItemInfo().index) : this.findLastFocusedItemIndex();
            this.changeFocusedItemInfo(event, itemIndex);
            event.preventDefault();
        }
    }
    onArrowLeftKey(event) {
        const processedItem = this.findVisibleItem(this.focusedItemInfo().index);
        const grouped = this.isProccessedItemGroup(processedItem);
        if (grouped) {
            if (this.orientation === 'horizontal') {
                const itemIndex = this.focusedItemInfo().index !== -1 ? this.findPrevItemIndex(this.focusedItemInfo().index) : this.findLastFocusedItemIndex();
                this.changeFocusedItemInfo(event, itemIndex);
            }
        }
        else {
            if (this.orientation === 'vertical' && isNotEmpty(this.activeItem())) {
                if (processedItem.columnIndex === 0) {
                    this.focusedItemInfo.set({
                        index: this.activeItem().index,
                        key: this.activeItem().key,
                        parentKey: this.activeItem().parentKey,
                        item: processedItem.item
                    });
                    this.activeItem.set(null);
                }
            }
            const columnIndex = processedItem.columnIndex - 1;
            const itemIndex = this.visibleItems.findIndex((item) => item.columnIndex === columnIndex);
            itemIndex !== -1 && this.changeFocusedItemInfo(event, itemIndex);
        }
        event.preventDefault();
    }
    onHomeKey(event) {
        this.changeFocusedItemInfo(event, this.findFirstItemIndex());
        event.preventDefault();
    }
    onEndKey(event) {
        this.changeFocusedItemInfo(event, this.findLastItemIndex());
        event.preventDefault();
    }
    onSpaceKey(event) {
        this.onEnterKey(event);
    }
    onEscapeKey(event) {
        if (isNotEmpty(this.activeItem())) {
            this.focusedItemInfo.set({ index: this.activeItem().index, key: this.activeItem().key, item: this.activeItem().item });
            this.activeItem.set(null);
        }
        event.preventDefault();
    }
    onTabKey(event) {
        if (this.focusedItemInfo().index !== -1) {
            const processedItem = this.findVisibleItem(this.focusedItemInfo().index);
            const grouped = this.isProccessedItemGroup(processedItem);
            !grouped && this.onItemChange({ originalEvent: event, processedItem });
        }
        this.hide();
    }
    onEnterKey(event) {
        if (this.focusedItemInfo().index !== -1) {
            const element = findSingle(this.rootmenu?.el?.nativeElement, `li[id="${`${this.focusedItemId}`}"]`);
            const anchorElement = element && (findSingle(element, '[data-pc-section="itemlink"]') || findSingle(element, 'a,button'));
            anchorElement ? anchorElement.click() : element && element.click();
            const processedItem = this.visibleItems[this.focusedItemInfo().index];
            const grouped = this.isProccessedItemGroup(processedItem);
            !grouped && this.changeFocusedItemInfo(event, this.findFirstFocusedItemIndex());
        }
        event.preventDefault();
    }
    findVisibleItem(index) {
        return isNotEmpty(this.visibleItems) ? this.visibleItems[index] : null;
    }
    findLastFocusedItemIndex() {
        const selectedIndex = this.findSelectedItemIndex();
        return selectedIndex < 0 ? this.findLastItemIndex() : selectedIndex;
    }
    findLastItemIndex() {
        return findLastIndex(this.visibleItems, (processedItem) => this.isValidItem(processedItem));
    }
    findPrevItemIndex(index) {
        const matchedItemIndex = index > 0 ? findLastIndex(this.visibleItems.slice(0, index), (processedItem) => this.isValidItem(processedItem)) : -1;
        return matchedItemIndex > -1 ? matchedItemIndex : index;
    }
    findNextItemIndex(index) {
        const matchedItemIndex = index < this.visibleItems.length - 1 ? this.visibleItems.slice(index + 1).findIndex((processedItem) => this.isValidItem(processedItem)) : -1;
        return matchedItemIndex > -1 ? matchedItemIndex + index + 1 : index;
    }
    bindResizeListener() {
        if (!this.resizeListener) {
            this.resizeListener = (event) => {
                if (!isTouchDevice()) {
                    this.hide(event, true);
                }
                this.mobileActive = false;
            };
            window.addEventListener('resize', this.resizeListener);
        }
    }
    bindOutsideClickListener() {
        if (isPlatformBrowser(this.platformId)) {
            if (!this.outsideClickListener) {
                this.outsideClickListener = this.renderer.listen(this.document, 'click', (event) => {
                    const isOutsideContainer = this.el?.nativeElement !== event.target && !this.el?.nativeElement.contains(event.target);
                    if (isOutsideContainer) {
                        this.hide();
                    }
                });
            }
        }
    }
    unbindOutsideClickListener() {
        if (this.outsideClickListener) {
            this.outsideClickListener();
            this.outsideClickListener = null;
        }
    }
    unbindResizeListener() {
        if (this.resizeListener) {
            window.removeEventListener('resize', this.resizeListener);
            this.resizeListener = null;
        }
    }
    onDestroy() {
        this.unbindOutsideClickListener();
        this.unbindResizeListener();
        this.unbindMatchMediaListener();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.5", ngImport: i0, type: MegaMenu, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "21.0.5", type: MegaMenu, isStandalone: true, selector: "p-megaMenu, p-megamenu, p-mega-menu", inputs: { model: "model", styleClass: "styleClass", orientation: "orientation", id: "id", ariaLabel: "ariaLabel", ariaLabelledBy: "ariaLabelledBy", breakpoint: "breakpoint", scrollHeight: "scrollHeight", disabled: ["disabled", "disabled", booleanAttribute], tabindex: ["tabindex", "tabindex", numberAttribute] }, host: { properties: { "class": "cn(cx(\"root\"), styleClass)", "id": "id" } }, providers: [MegaMenuStyle, { provide: MEGAMENU_INSTANCE, useExisting: MegaMenu }, { provide: PARENT_INSTANCE, useExisting: MegaMenu }], queries: [{ propertyName: "startTemplate", first: true, predicate: ["start"] }, { propertyName: "endTemplate", first: true, predicate: ["end"] }, { propertyName: "menuIconTemplate", first: true, predicate: ["menuicon"] }, { propertyName: "submenuIconTemplate", first: true, predicate: ["submenuicon"] }, { propertyName: "itemTemplate", first: true, predicate: ["item"] }, { propertyName: "buttonTemplate", first: true, predicate: ["button"] }, { propertyName: "buttonIconTemplate", first: true, predicate: ["buttonicon"] }, { propertyName: "templates", predicate: PrimeTemplate }], viewQueries: [{ propertyName: "menubuttonViewChild", first: true, predicate: ["menubutton"], descendants: true }, { propertyName: "rootmenu", first: true, predicate: ["rootmenu"], descendants: true }], usesInheritance: true, hostDirectives: [{ directive: i1.Bind }], ngImport: i0, template: `
        <div [class]="cx('start')" *ngIf="startTemplate || _startTemplate" [pBind]="ptm('start')">
            <ng-container *ngTemplateOutlet="startTemplate || _startTemplate"></ng-container>
        </div>
        <ng-container *ngIf="!buttonTemplate && !_buttonTemplate">
            <a
                *ngIf="model && model.length > 0"
                #menubutton
                role="button"
                tabindex="0"
                [class]="cx('button')"
                [attr.aria-haspopup]="model.length && model.length > 0 ? true : false"
                [attr.aria-expanded]="mobileActive"
                [attr.aria-controls]="id"
                [attr.aria-label]="config.translation.aria.navigation"
                [pBind]="ptm('button')"
                (click)="menuButtonClick($event)"
                (keydown)="menuButtonKeydown($event)"
            >
                <svg data-p-icon="bars" *ngIf="!buttonIconTemplate && !_buttonIconTemplate" [pBind]="ptm('buttonIcon')" />
                <ng-template *ngTemplateOutlet="buttonIconTemplate || _buttonIconTemplate"></ng-template>
            </a>
        </ng-container>
        <ng-container *ngTemplateOutlet="buttonTemplate || _buttonTemplate"></ng-container>
        <ul
            pMegaMenuSub
            #rootmenu
            [itemTemplate]="itemTemplate || _itemTemplate"
            [items]="processedItems"
            [attr.id]="id + '_list'"
            [menuId]="id"
            [root]="true"
            [orientation]="orientation"
            [ariaLabel]="ariaLabel"
            [disabled]="disabled"
            [tabindex]="!disabled ? tabindex : -1"
            [activeItem]="activeItem()"
            [level]="0"
            [ariaLabelledBy]="ariaLabelledBy"
            [focusedItemId]="focused ? focusedItemId : undefined"
            [mobileActive]="mobileActive"
            (itemClick)="onItemClick($event)"
            (menuFocus)="onMenuFocus($event)"
            (menuBlur)="onMenuBlur($event)"
            (menuKeydown)="onKeyDown($event)"
            (menuMouseDown)="onMenuMouseDown($event)"
            (itemMouseEnter)="onItemMouseEnter($event)"
            [queryMatches]="queryMatches()"
            [scrollHeight]="scrollHeight"
            [pt]="pt()"
            [unstyled]="unstyled()"
        ></ul>
        <div [class]="cx('end')" *ngIf="endTemplate || _endTemplate" [pBind]="ptm('end')">
            <ng-container *ngTemplateOutlet="endTemplate || _endTemplate"></ng-container>
        </div>
    `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "ngmodule", type: RouterModule }, { kind: "component", type: MegaMenuSub, selector: "p-megaMenuSub, p-megamenu-sub, ul[pMegaMenuSub]", inputs: ["id", "items", "itemTemplate", "menuId", "ariaLabel", "ariaLabelledBy", "level", "focusedItemId", "disabled", "orientation", "activeItem", "submenu", "queryMatches", "mobileActive", "scrollHeight", "tabindex", "root"], outputs: ["itemClick", "itemMouseEnter", "menuFocus", "menuBlur", "menuKeydown", "menuMouseDown"] }, { kind: "ngmodule", type: TooltipModule }, { kind: "directive", type: i1.Bind, selector: "[pBind]", inputs: ["pBind"] }, { kind: "component", type: BarsIcon, selector: "[data-p-icon=\"bars\"]" }, { kind: "ngmodule", type: BadgeModule }, { kind: "ngmodule", type: SharedModule }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.5", ngImport: i0, type: MegaMenu, decorators: [{
            type: Component,
            args: [{
                    selector: 'p-megaMenu, p-megamenu, p-mega-menu',
                    standalone: true,
                    imports: [CommonModule, RouterModule, MegaMenuSub, TooltipModule, BarsIcon, BadgeModule, SharedModule, Bind],
                    template: `
        <div [class]="cx('start')" *ngIf="startTemplate || _startTemplate" [pBind]="ptm('start')">
            <ng-container *ngTemplateOutlet="startTemplate || _startTemplate"></ng-container>
        </div>
        <ng-container *ngIf="!buttonTemplate && !_buttonTemplate">
            <a
                *ngIf="model && model.length > 0"
                #menubutton
                role="button"
                tabindex="0"
                [class]="cx('button')"
                [attr.aria-haspopup]="model.length && model.length > 0 ? true : false"
                [attr.aria-expanded]="mobileActive"
                [attr.aria-controls]="id"
                [attr.aria-label]="config.translation.aria.navigation"
                [pBind]="ptm('button')"
                (click)="menuButtonClick($event)"
                (keydown)="menuButtonKeydown($event)"
            >
                <svg data-p-icon="bars" *ngIf="!buttonIconTemplate && !_buttonIconTemplate" [pBind]="ptm('buttonIcon')" />
                <ng-template *ngTemplateOutlet="buttonIconTemplate || _buttonIconTemplate"></ng-template>
            </a>
        </ng-container>
        <ng-container *ngTemplateOutlet="buttonTemplate || _buttonTemplate"></ng-container>
        <ul
            pMegaMenuSub
            #rootmenu
            [itemTemplate]="itemTemplate || _itemTemplate"
            [items]="processedItems"
            [attr.id]="id + '_list'"
            [menuId]="id"
            [root]="true"
            [orientation]="orientation"
            [ariaLabel]="ariaLabel"
            [disabled]="disabled"
            [tabindex]="!disabled ? tabindex : -1"
            [activeItem]="activeItem()"
            [level]="0"
            [ariaLabelledBy]="ariaLabelledBy"
            [focusedItemId]="focused ? focusedItemId : undefined"
            [mobileActive]="mobileActive"
            (itemClick)="onItemClick($event)"
            (menuFocus)="onMenuFocus($event)"
            (menuBlur)="onMenuBlur($event)"
            (menuKeydown)="onKeyDown($event)"
            (menuMouseDown)="onMenuMouseDown($event)"
            (itemMouseEnter)="onItemMouseEnter($event)"
            [queryMatches]="queryMatches()"
            [scrollHeight]="scrollHeight"
            [pt]="pt()"
            [unstyled]="unstyled()"
        ></ul>
        <div [class]="cx('end')" *ngIf="endTemplate || _endTemplate" [pBind]="ptm('end')">
            <ng-container *ngTemplateOutlet="endTemplate || _endTemplate"></ng-container>
        </div>
    `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    providers: [MegaMenuStyle, { provide: MEGAMENU_INSTANCE, useExisting: MegaMenu }, { provide: PARENT_INSTANCE, useExisting: MegaMenu }],
                    host: {
                        '[class]': 'cn(cx("root"), styleClass)',
                        '[id]': 'id'
                    },
                    hostDirectives: [Bind]
                }]
        }], ctorParameters: () => [], propDecorators: { model: [{
                type: Input
            }], styleClass: [{
                type: Input
            }], orientation: [{
                type: Input
            }], id: [{
                type: Input
            }], ariaLabel: [{
                type: Input
            }], ariaLabelledBy: [{
                type: Input
            }], breakpoint: [{
                type: Input
            }], scrollHeight: [{
                type: Input
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], tabindex: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], startTemplate: [{
                type: ContentChild,
                args: ['start', { descendants: false }]
            }], endTemplate: [{
                type: ContentChild,
                args: ['end', { descendants: false }]
            }], menuIconTemplate: [{
                type: ContentChild,
                args: ['menuicon', { descendants: false }]
            }], submenuIconTemplate: [{
                type: ContentChild,
                args: ['submenuicon', { descendants: false }]
            }], itemTemplate: [{
                type: ContentChild,
                args: ['item', { descendants: false }]
            }], buttonTemplate: [{
                type: ContentChild,
                args: ['button', { descendants: false }]
            }], buttonIconTemplate: [{
                type: ContentChild,
                args: ['buttonicon', { descendants: false }]
            }], templates: [{
                type: ContentChildren,
                args: [PrimeTemplate]
            }], menubuttonViewChild: [{
                type: ViewChild,
                args: ['menubutton']
            }], rootmenu: [{
                type: ViewChild,
                args: ['rootmenu']
            }] } });
class MegaMenuModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.5", ngImport: i0, type: MegaMenuModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "21.0.5", ngImport: i0, type: MegaMenuModule, imports: [MegaMenu, SharedModule], exports: [MegaMenu, SharedModule] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "21.0.5", ngImport: i0, type: MegaMenuModule, imports: [MegaMenu, SharedModule, SharedModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.5", ngImport: i0, type: MegaMenuModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [MegaMenu, SharedModule],
                    exports: [MegaMenu, SharedModule]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { MegaMenu, MegaMenuClasses, MegaMenuModule, MegaMenuStyle, MegaMenuSub };
//# sourceMappingURL=primeng-megamenu.mjs.map
