import { isPlatformBrowser } from '@angular/common';
import * as i0 from '@angular/core';
import { Injectable, inject, NgZone, effect, Directive, NgModule } from '@angular/core';
import { removeClass, getHeight, getWidth, getOuterWidth, getOuterHeight, getOffset, addClass, remove } from '@primeuix/utils';
import { BaseComponent } from 'primeng/basecomponent';
import { style as style$1 } from '@primeuix/styles/ripple';
import { BaseStyle } from 'primeng/base';

const style = /*css*/ `
    ${style$1}

    /* For PrimeNG */
    .p-ripple {
        overflow: hidden;
        position: relative;
    }

    .p-ripple-disabled .p-ink {
        display: none !important;
    }

    @keyframes ripple {
        100% {
            opacity: 0;
            transform: scale(2.5);
        }
    }
`;
const classes = {
    root: 'p-ink'
};
class RippleStyle extends BaseStyle {
    name = 'ripple';
    style = style;
    classes = classes;
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.5", ngImport: i0, type: RippleStyle, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "21.0.5", ngImport: i0, type: RippleStyle });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.5", ngImport: i0, type: RippleStyle, decorators: [{
            type: Injectable
        }] });
/**
 *
 * Ripple directive adds ripple effect to the host element.
 *
 * [Live Demo](https://www.primeng.org/ripple)
 *
 * @module ripplestyle
 *
 */
var RippleClasses;
(function (RippleClasses) {
    /**
     * Class name of the root element
     */
    RippleClasses["root"] = "p-ink";
})(RippleClasses || (RippleClasses = {}));

/**
 * Ripple directive adds ripple effect to the host element.
 * @group Components
 */
class Ripple extends BaseComponent {
    zone = inject(NgZone);
    _componentStyle = inject(RippleStyle);
    animationListener;
    mouseDownListener;
    timeout;
    constructor() {
        super();
        effect(() => {
            if (isPlatformBrowser(this.platformId)) {
                if (this.config.ripple()) {
                    this.zone.runOutsideAngular(() => {
                        this.create();
                        this.mouseDownListener = this.renderer.listen(this.el.nativeElement, 'mousedown', this.onMouseDown.bind(this));
                    });
                }
                else {
                    this.remove();
                }
            }
        });
    }
    onAfterViewInit() { }
    onMouseDown(event) {
        let ink = this.getInk();
        if (!ink || this.document.defaultView?.getComputedStyle(ink, null).display === 'none') {
            return;
        }
        !this.$unstyled() && removeClass(ink, 'p-ink-active');
        ink.setAttribute('data-p-ink-active', 'false');
        if (!getHeight(ink) && !getWidth(ink)) {
            let d = Math.max(getOuterWidth(this.el.nativeElement), getOuterHeight(this.el.nativeElement));
            ink.style.height = d + 'px';
            ink.style.width = d + 'px';
        }
        let offset = getOffset(this.el.nativeElement);
        let x = event.pageX - offset.left + this.document.body.scrollTop - getWidth(ink) / 2;
        let y = event.pageY - offset.top + this.document.body.scrollLeft - getHeight(ink) / 2;
        this.renderer.setStyle(ink, 'top', y + 'px');
        this.renderer.setStyle(ink, 'left', x + 'px');
        !this.$unstyled() && addClass(ink, 'p-ink-active');
        ink.setAttribute('data-p-ink-active', 'true');
        this.timeout = setTimeout(() => {
            let ink = this.getInk();
            if (ink) {
                !this.$unstyled() && removeClass(ink, 'p-ink-active');
                ink.setAttribute('data-p-ink-active', 'false');
            }
        }, 401);
    }
    getInk() {
        const children = this.el.nativeElement.children;
        for (let i = 0; i < children.length; i++) {
            if (typeof children[i].className === 'string' && children[i].className.indexOf('p-ink') !== -1) {
                return children[i];
            }
        }
        return null;
    }
    resetInk() {
        let ink = this.getInk();
        if (ink) {
            !this.$unstyled() && removeClass(ink, 'p-ink-active');
            ink.setAttribute('data-p-ink-active', 'false');
        }
    }
    onAnimationEnd(event) {
        if (this.timeout) {
            clearTimeout(this.timeout);
        }
        !this.$unstyled() && removeClass(event.currentTarget, 'p-ink-active');
        event.currentTarget.setAttribute('data-p-ink-active', 'false');
    }
    create() {
        let ink = this.renderer.createElement('span');
        this.renderer.addClass(ink, 'p-ink');
        this.renderer.appendChild(this.el.nativeElement, ink);
        this.renderer.setAttribute(ink, 'data-p-ink', 'true');
        this.renderer.setAttribute(ink, 'data-p-ink-active', 'false');
        this.renderer.setAttribute(ink, 'aria-hidden', 'true');
        this.renderer.setAttribute(ink, 'role', 'presentation');
        if (!this.animationListener) {
            this.animationListener = this.renderer.listen(ink, 'animationend', this.onAnimationEnd.bind(this));
        }
    }
    remove() {
        let ink = this.getInk();
        if (ink) {
            this.mouseDownListener && this.mouseDownListener();
            this.animationListener && this.animationListener();
            this.mouseDownListener = null;
            this.animationListener = null;
            remove(ink);
        }
    }
    onDestroy() {
        if (this.config && this.config.ripple()) {
            this.remove();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.5", ngImport: i0, type: Ripple, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "21.0.5", type: Ripple, isStandalone: true, selector: "[pRipple]", host: { classAttribute: "p-ripple" }, providers: [RippleStyle], usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.5", ngImport: i0, type: Ripple, decorators: [{
            type: Directive,
            args: [{
                    selector: '[pRipple]',
                    host: {
                        class: 'p-ripple'
                    },
                    standalone: true,
                    providers: [RippleStyle]
                }]
        }], ctorParameters: () => [] });
class RippleModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "21.0.5", ngImport: i0, type: RippleModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "21.0.5", ngImport: i0, type: RippleModule, imports: [Ripple], exports: [Ripple] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "21.0.5", ngImport: i0, type: RippleModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "21.0.5", ngImport: i0, type: RippleModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [Ripple],
                    exports: [Ripple]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { Ripple, RippleClasses, RippleModule, RippleStyle };
//# sourceMappingURL=primeng-ripple.mjs.map
